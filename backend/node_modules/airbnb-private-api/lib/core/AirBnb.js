'use strict';
var __decorate =
    (this && this.__decorate) ||
    function(decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
            d;
        if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function') r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
var __metadata =
    (this && this.__metadata) ||
    function(k, v) {
        if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function') return Reflect.metadata(k, v);
    };
var __importDefault =
    (this && this.__importDefault) ||
    function(mod) {
        return mod && mod.__esModule ? mod : { default: mod };
    };
Object.defineProperty(exports, '__esModule', { value: true });
const request_promise_1 = __importDefault(require('request-promise'));
const uuid_1 = require('uuid');
const pretty_error_1 = require('pretty-error');
pretty_error_1.start();
const constant_1 = require('../constant');
const decorators_1 = require('../decorators');
const helpers_1 = require('../helpers');
const SessionManager_1 = require('./SessionManager');
class AirBnbClient extends SessionManager_1.SessionManager {
    constructor({
        email = '',
        phone = '',
        password = '',
        auth_token = '',
        proxy = '',
        currency = 'USD',
        locale = 'en-US',
        session_store = 'file',
        session_path = '',
    }) {
        const session = {
            user_agent: constant_1.user_agents[0].user_agent,
            advertising_id: uuid_1.v4(),
            device: {
                id: helpers_1.random_id(16, false),
                fingerprint: helpers_1.random_id(64, true),
                screen_size: constant_1.user_agents[0].screen_size,
                country: 'us',
            },
        };
        super({
            session_store,
            session,
            session_path,
            auth_token,
            email,
            phone,
            currency,
            locale,
            authenticated: false,
            valid_store: false,
        });
        this.phone = phone;
        this.email = email;
        this.password = password;
        this.auth_token = auth_token;
        this.proxy = proxy;
        this.currency = currency;
        this.locale = locale;
        this.session = session;
        this.authenticated = false;
        this.valid_store = false;
    }
    _request({ uri, method, qs, body, form, headers, json, proxy, apply_auth_qs, qsStringifyOptions = false }) {
        return new Promise(async (resolve, reject) => {
            const query = Object.assign(
                Object.assign(
                    Object.assign(
                        Object.assign(
                            Object.assign(Object.assign(Object.assign({ uri, method }, body ? { body } : {}), form ? { form } : {}), {
                                qs: Object.assign(
                                    Object.assign({}, qs),
                                    apply_auth_qs
                                        ? {
                                              client_id: constant_1.api_key,
                                              locale: this.locale,
                                              currency: this.currency,
                                          }
                                        : {},
                                ),
                                headers: Object.assign(
                                    Object.assign(
                                        Object.assign(
                                            {
                                                'user-agent': this.session.user_agent,
                                                'x-airbnb-advertising-id': this.session.advertising_id,
                                                'x-airbnb-device-id': this.session.device.id,
                                                'x-airbnb-device-fingerprint': this.session.device.fingerprint,
                                                'x-airbnb-screensize': this.session.device.screen_size,
                                                'x-airbnb-carrier-country': this.session.device.country,
                                            },
                                            this.authenticated ? { 'x-airbnb-oauth-token': this.auth_token } : {},
                                        ),
                                        {
                                            'accept-encoding': 'gzip',
                                            'content-type': 'application/x-www-form-urlencoded; charset=UTF-8 ',
                                            'x-airbnb-network-type': 'wifi',
                                            'x-return-strategy': 'single',
                                        },
                                    ),
                                    headers,
                                ),
                            }),
                            qsStringifyOptions ? { qsStringifyOptions: { indices: false } } : {},
                        ),
                        json ? { json: true } : {},
                    ),
                    { gzip: true, resolveWithFullResponse: true },
                ),
                this.proxy ? { proxy: `https://${this.proxy}/` } : {},
            );
            try {
                const response = await request_promise_1.default(query);
                resolve(response);
            } catch ({ error, name }) {
                if (name === 'StatusCodeError') {
                    return reject(Object.assign({ type: 'StatusCodeError' }, error));
                }
                reject(error);
            }
        });
    }
    _authentication_by_email() {
        return new Promise(async (resolve, reject) => {
            try {
                await this._validate_store();
                resolve(await this._authentication('email'));
            } catch (error) {
                reject(error);
            }
        });
    }
    _send_auth_code_to_phone() {
        return new Promise(async (resolve, reject) => {
            const query = {
                uri: constant_1.endpoints.phone_one_time_passwords,
                method: 'POST',
                body: {
                    otpMethod: 'AUTO',
                    phoneNumber: this.phone,
                    workFlow: 'GLOBAL_SIGNUP_LOGIN',
                },
                headers: {
                    'content-type': 'application/json; charset=UTF-8',
                },
                apply_auth_qs: true,
                json: true,
            };
            try {
                await this._validate_store();
                const response = await this._request(query);
                resolve(response.body);
            } catch (error) {
                reject(error);
            }
        });
    }
    _authentication_by_phone(code) {
        return new Promise(async (resolve, reject) => {
            try {
                resolve(await this._authentication('phone', code));
            } catch (error) {
                reject(error);
            }
        });
    }
    _authentication(type, code = 0) {
        return new Promise(async (resolve, reject) => {
            const query = {
                uri: constant_1.endpoints.authentications,
                method: 'POST',
                qs: {
                    client_id: constant_1.api_key,
                    locale: this.locale,
                    currency: this.currency,
                },
                body: {
                    authenticationParams: Object.assign(
                        {},
                        type === 'email'
                            ? {
                                  email: {
                                      email: this.email,
                                      password: this.password,
                                  },
                              }
                            : {
                                  phone: {
                                      deliveryMethod: 'TEXT',
                                      isCombinedFlow: false,
                                      isGlobal: true,
                                      otp: code,
                                      phoneNumber: this.phone,
                                  },
                              },
                    ),
                    metadata: {
                        sxsMode: 'OFF',
                    },
                },
                headers: {
                    'content-type': 'application/json; charset=UTF-8',
                },
                json: true,
            };
            try {
                const response = await this._request(query);
                this.auth_token = response.body.token;
                this.session = Object.assign(Object.assign({}, this.session), {
                    token: response.body.token,
                    user: {
                        currency: this.currency,
                        locale: this.locale,
                        user_id: response.body.filledAccountData.userId,
                    },
                });
                this.authenticated = true;
                await this._save_session();
                resolve(response.body);
            } catch (error) {
                reject(error);
            }
        });
    }
    _get_my_profile() {
        return new Promise(async (resolve, reject) => {
            const query = {
                uri: constant_1.endpoints.accounts_me,
                method: 'GET',
                apply_auth_qs: true,
                json: true,
            };
            try {
                const response = await this._request(query);
                resolve(response.body);
            } catch (error) {
                reject(error);
            }
        });
    }
    _get_user_profile(user_id) {
        return new Promise(async (resolve, reject) => {
            if (typeof user_id !== 'number') {
                return reject({ type: 'Function', method: '_get_user_profile', error_message: 'id can only be a positive number' });
            }
            const query = {
                uri: constant_1.endpoints.user_by_id(user_id),
                method: 'GET',
                apply_auth_qs: true,
                json: true,
            };
            try {
                const response = await this._request(query);
                resolve(response.body);
            } catch (error) {
                reject(error);
            }
        });
    }
    _get_wishlists({ _offset = 0, _limit = 10 }) {
        return new Promise(async (resolve, reject) => {
            if (typeof _offset !== 'number' || typeof _limit !== 'number') {
                return reject({ type: 'Function', method: '_get_thread_ids', error_message: 'offset and limit can only be a positive numbers' });
            }
            const query = {
                uri: constant_1.endpoints.wishlists,
                method: 'GET',
                qs: {
                    _format: 'for_mobile_private_index',
                    _limit,
                    _offset,
                    include_shared_wishlists: true,
                },
                apply_auth_qs: true,
                json: true,
            };
            try {
                const response = await this._request(query);
                resolve(response.body);
            } catch (error) {
                reject(error);
            }
        });
    }
    _get_listings({ id = 0, _limit = 10 }) {
        return new Promise(async (resolve, reject) => {
            if (typeof _limit !== 'number' || typeof id !== 'number') {
                return reject({ type: 'Function', method: '_get_listings', error_message: '_limit and id can only be a positive number (>=0)' });
            }
            const query = {
                uri: constant_1.endpoints.listings(id),
                method: 'GET',
                qs: Object.assign(
                    Object.assign(
                        {},
                        !id
                            ? {
                                  _limit,
                                  user_id: this.session.user.user_id,
                              }
                            : {},
                    ),
                    { _format: 'v1_legacy_long_manage_listing' },
                ),
                apply_auth_qs: true,
                json: true,
            };
            try {
                const response = await this._request(query);
                resolve(response.body);
            } catch (error) {
                reject(error);
            }
        });
    }
    _messaging_syncs({ type = 'host', _limit = 10 }) {
        return new Promise(async (resolve, reject) => {
            if (!helpers_1.validate_user_type(type)) {
                return reject({ type: 'Function', method: '_messaging_syncs', error_message: `type can only be: ${constant_1.user_types}` });
            }
            const query = {
                uri: constant_1.endpoints.messaging_syncs,
                method: 'GET',
                qs: {
                    _limit,
                    include_generic_bessie_threads: true,
                    include_luxury_assisted_booking_threads: true,
                    include_mt: true,
                    include_plus_onboarding_threads: true,
                    include_restaurant_threads: true,
                    include_support_messaging_threads: true,
                    selected_inbox_type: type,
                    sequence_id: (Date.now() / 1000) | 0,
                },
                apply_auth_qs: true,
                json: true,
            };
            try {
                const response = await this._request(query);
                resolve(response.body);
            } catch (error) {
                reject(error);
            }
        });
    }
    _get_threads_full({ _limit = 10, type = 'host' }) {
        return new Promise(async (resolve, reject) => {
            if (!helpers_1.validate_user_type(type)) {
                return reject({ type: 'Function', method: '_get_threads_full', error_message: `type can only be: ${constant_1.user_types}` });
            }
            try {
                const response = this._threads({
                    selected_inbox_type: type,
                    _limit,
                    full: true,
                });
                resolve(response);
            } catch (error) {
                reject(error);
            }
        });
    }
    _get_threads_ids({ _limit = 10, _offset = 0, type = 'host' }) {
        return new Promise(async (resolve, reject) => {
            if (!helpers_1.validate_user_type(type)) {
                return reject({ type: 'Function', method: '_get_threads_ids', error_message: `type can only be ${constant_1.user_types}` });
            }
            try {
                const response = this._threads({
                    selected_inbox_type: type,
                    _limit,
                    _offset,
                    full: false,
                });
                resolve(response);
            } catch (error) {
                reject(error);
            }
        });
    }
    _get_thread_by_id({ id }) {
        return new Promise(async (resolve, reject) => {
            if (typeof id !== 'number' || id <= 0) {
                return reject({ type: 'Function', method: '_get_thread_by_id', error_message: `id can only be a positive number(>0)` });
            }
            try {
                const response = this._threads({
                    id,
                });
                resolve(response);
            } catch (error) {
                reject(error);
            }
        });
    }
    _threads({ id, _limit, selected_inbox_type, full, _offset }) {
        return new Promise(async (resolve, reject) => {
            const query = {
                uri: constant_1.endpoints.threads(id),
                method: 'GET',
                qs: Object.assign(
                    {},
                    id
                        ? {
                              _format: 'for_messaging_sync_with_posts_china',
                          }
                        : Object.assign(
                              { _limit, selected_inbox_type },
                              full
                                  ? {
                                        _format: 'for_messaging_sync_with_posts_china',
                                        include_generic_bessie_threads: true,
                                        include_luxury_assisted_booking_threads: true,
                                        include_mt: true,
                                        include_plus_onboarding_threads: true,
                                        include_restaurant_threads: true,
                                        include_support_messaging_threads: true,
                                        role: 'all',
                                    }
                                  : {
                                        _offset,
                                    },
                          ),
                ),
                apply_auth_qs: true,
                json: true,
            };
            try {
                const response = await this._request(query);
                resolve(response.body);
            } catch (error) {
                reject(error);
            }
        });
    }
    _update_calendar_note({ listing_id, dates, notes }) {
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._update_calendar(listing_id, { notes, dates });
                resolve(response.body);
            } catch (error) {
                reject(error);
            }
        });
    }
    _update_calendar_smart_pricing({ listing_id, active, dates }) {
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._update_calendar(listing_id, { demand_based_pricing_overridden: !active, dates });
                resolve(response.body);
            } catch (error) {
                reject(error);
            }
        });
    }
    _update_calendar_availability({ listing_id, availability, dates }) {
        return new Promise(async (resolve, reject) => {
            try {
                const availability_status = availability ? 'available' : 'unavailable_persistent';
                const response = await this._update_calendar(listing_id, { availability: availability_status, dates });
                resolve(response.body);
            } catch (error) {
                reject(error);
            }
        });
    }
    _update_calendar_price({ listing_id, daily_price, dates }) {
        return new Promise(async (resolve, reject) => {
            try {
                const response = await this._update_calendar(listing_id, { daily_price, dates });
                resolve(response.body);
            } catch (error) {
                reject(error);
            }
        });
    }
    _update_calendar(listing_id, operations) {
        return new Promise(async (resolve, reject) => {
            const query = {
                uri: constant_1.endpoints.calendar_operations,
                method: 'POST',
                qs: {
                    _format: 'host_calendar_detailed',
                },
                body: {
                    listing_id,
                    method: 'UPDATE',
                    operations: [Object.assign({}, operations)],
                },
                headers: {
                    'content-type': 'application/json; charset=UTF-8',
                },
                apply_auth_qs: true,
                json: true,
            };
            try {
                const response = await this._request(query);
                resolve(response);
            } catch (error) {
                reject(error);
            }
        });
    }
    _get_host_pricing_calculators({ check_in, check_out, listing_id }) {
        return new Promise(async (resolve, reject) => {
            const query = {
                uri: constant_1.endpoints.host_pricing_calculators,
                method: 'GET',
                qs: {
                    _format: 'default',
                    check_in,
                    guests: 1,
                    check_out,
                    listing_id,
                },
                apply_auth_qs: true,
                json: true,
            };
            try {
                const response = await this._request(query);
                resolve(response.body);
            } catch (error) {
                reject(error);
            }
        });
    }
    _get_reservations({
        _limit = 30,
        _offset = 0,
        start_date = new Date().toISOString().substring(0, 10),
        end_date = '',
        order_by = 'start_date',
        include_accept = true,
        include_canceled = false,
        include_checkpoint = false,
        include_pending = false,
    }) {
        return new Promise(async (resolve, reject) => {
            if (!helpers_1.validate_reservation_order(order_by)) {
                return reject({
                    type: 'Function',
                    method: '_get_reservations',
                    error_message: `you can order only by: ${constant_1.reservation_order}`,
                });
            }
            const query = {
                uri: constant_1.endpoints.reservations,
                method: 'GET',
                qs: Object.assign(
                    Object.assign({ _format: 'for_mobile_list', _limit, _offset, _order: order_by, start_date }, end_date ? { end_date } : {}),
                    {
                        host_id: this.session.user.user_id,
                        for_calendar_thumbnail: true,
                        include_accept,
                        include_canceled,
                        include_checkpoint,
                        include_pending,
                    },
                ),
                apply_auth_qs: true,
                json: true,
            };
            try {
                const response = await this._request(query);
                resolve(response.body);
            } catch (error) {
                reject(error);
            }
        });
    }
    _get_reservation_details(reservation_id) {
        return new Promise(async (resolve, reject) => {
            const query = {
                uri: constant_1.endpoints.homes_booking_details(reservation_id),
                method: 'GET',
                qs: {
                    _format: 'for_host_reservation_details_v2',
                },
                apply_auth_qs: true,
                json: true,
            };
            try {
                const response = await this._request(query);
                resolve(response.body);
            } catch (error) {
                reject(error);
            }
        });
    }
    _get_listings_from_search({
        adults,
        children = 0,
        infants = 0,
        checkin,
        checkout,
        _offset = 0,
        _limit = 30,
        query = '',
        is_guided_search = false,
        amenities = [],
        ib = false,
        price_min,
        price_max,
        min_bathrooms,
        min_bedrooms,
        min_beds,
        superhost = false,
        room_types = [],
    }) {
        return new Promise(async (resolve, reject) => {
            const requestQuery = {
                uri: `${constant_1.endpoints.explore_tabs}`,
                method: 'GET',
                qs: Object.assign(
                    Object.assign(
                        Object.assign(
                            Object.assign(
                                Object.assign(
                                    Object.assign(
                                        Object.assign(
                                            Object.assign(
                                                {
                                                    _format: 'for_explore_search_native',
                                                    adults,
                                                    checkin,
                                                    checkout,
                                                    children,
                                                    fetch_filters: true,
                                                    gps_lat: 0.0,
                                                    gps_lng: 0.0,
                                                    infants,
                                                    is_guided_search,
                                                    items_offset: _offset,
                                                    items_per_grid: _limit,
                                                    query,
                                                },
                                                price_min ? { price_min } : {},
                                            ),
                                            price_max ? { price_max } : {},
                                        ),
                                        min_bathrooms ? { min_bathrooms } : {},
                                    ),
                                    min_bedrooms ? { min_bedrooms } : {},
                                ),
                                min_beds ? { min_beds } : {},
                            ),
                            ib ? { ib } : {},
                        ),
                        superhost ? { superhost } : {},
                    ),
                    { 'refinement_paths[]': '/homes', 'amenities[]': amenities, 'room_types[]': room_types, version: '1.7.3' },
                ),
                qsStringifyOptions: true,
                apply_auth_qs: true,
                json: true,
            };
            try {
                const response = await this._request(requestQuery);
                try {
                    resolve(response.body.explore_tabs[0].sections[1].listings);
                } catch (error) {
                    resolve([]);
                }
            } catch (error) {
                reject(error);
            }
        });
    }
}
__decorate(
    [
        decorators_1.requiredArguments(['email', 'password']),
        __metadata('design:type', Function),
        __metadata('design:paramtypes', []),
        __metadata('design:returntype', void 0),
    ],
    AirBnbClient.prototype,
    '_authentication_by_email',
    null,
);
__decorate(
    [
        decorators_1.requiredArguments(['phone']),
        __metadata('design:type', Function),
        __metadata('design:paramtypes', []),
        __metadata('design:returntype', Promise),
    ],
    AirBnbClient.prototype,
    '_send_auth_code_to_phone',
    null,
);
__decorate(
    [decorators_1.requireAuth, __metadata('design:type', Function), __metadata('design:paramtypes', []), __metadata('design:returntype', Promise)],
    AirBnbClient.prototype,
    '_get_my_profile',
    null,
);
__decorate(
    [
        decorators_1.requireAuth,
        __metadata('design:type', Function),
        __metadata('design:paramtypes', [Number]),
        __metadata('design:returntype', Promise),
    ],
    AirBnbClient.prototype,
    '_get_user_profile',
    null,
);
__decorate(
    [
        decorators_1.requireAuth,
        __metadata('design:type', Function),
        __metadata('design:paramtypes', [Object]),
        __metadata('design:returntype', Promise),
    ],
    AirBnbClient.prototype,
    '_get_wishlists',
    null,
);
__decorate(
    [
        decorators_1.requireAuth,
        __metadata('design:type', Function),
        __metadata('design:paramtypes', [Object]),
        __metadata('design:returntype', Promise),
    ],
    AirBnbClient.prototype,
    '_get_listings',
    null,
);
__decorate(
    [
        decorators_1.requireAuth,
        __metadata('design:type', Function),
        __metadata('design:paramtypes', [Object]),
        __metadata('design:returntype', void 0),
    ],
    AirBnbClient.prototype,
    '_messaging_syncs',
    null,
);
__decorate(
    [
        decorators_1.requireAuth,
        __metadata('design:type', Function),
        __metadata('design:paramtypes', [Object]),
        __metadata('design:returntype', void 0),
    ],
    AirBnbClient.prototype,
    '_get_threads_full',
    null,
);
__decorate(
    [
        decorators_1.requireAuth,
        __metadata('design:type', Function),
        __metadata('design:paramtypes', [Object]),
        __metadata('design:returntype', void 0),
    ],
    AirBnbClient.prototype,
    '_get_threads_ids',
    null,
);
__decorate(
    [
        decorators_1.requireAuth,
        __metadata('design:type', Function),
        __metadata('design:paramtypes', [Object]),
        __metadata('design:returntype', void 0),
    ],
    AirBnbClient.prototype,
    '_get_thread_by_id',
    null,
);
__decorate(
    [
        decorators_1.requireAuth,
        __metadata('design:type', Function),
        __metadata('design:paramtypes', [Object]),
        __metadata('design:returntype', Promise),
    ],
    AirBnbClient.prototype,
    '_threads',
    null,
);
__decorate(
    [
        decorators_1.requireAuth,
        __metadata('design:type', Function),
        __metadata('design:paramtypes', [Object, Object]),
        __metadata('design:returntype', Promise),
    ],
    AirBnbClient.prototype,
    '_update_calendar',
    null,
);
__decorate(
    [
        decorators_1.requireAuth,
        __metadata('design:type', Function),
        __metadata('design:paramtypes', [Object]),
        __metadata('design:returntype', Promise),
    ],
    AirBnbClient.prototype,
    '_get_host_pricing_calculators',
    null,
);
__decorate(
    [
        decorators_1.requireAuth,
        __metadata('design:type', Function),
        __metadata('design:paramtypes', [Object]),
        __metadata('design:returntype', Promise),
    ],
    AirBnbClient.prototype,
    '_get_reservations',
    null,
);
__decorate(
    [
        decorators_1.requireAuth,
        __metadata('design:type', Function),
        __metadata('design:paramtypes', [String]),
        __metadata('design:returntype', Promise),
    ],
    AirBnbClient.prototype,
    '_get_reservation_details',
    null,
);
__decorate(
    [
        decorators_1.requireAuth,
        __metadata('design:type', Function),
        __metadata('design:paramtypes', [Object]),
        __metadata('design:returntype', Promise),
    ],
    AirBnbClient.prototype,
    '_get_listings_from_search',
    null,
);
exports.AirBnbClient = AirBnbClient;
